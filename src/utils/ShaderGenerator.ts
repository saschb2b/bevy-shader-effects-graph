import { LGraph, LGraphNode } from 'litegraph.js';

export class ShaderGenerator {
  private graph: LGraph;
  private code: string[] = [];
  private vars: Map<string, string> = new Map(); // key (nodeId_slot) -> varName
  private usesNoise: boolean = false;

  constructor(graph: LGraph) {
    this.graph = graph;
  }

  generate(): string {
    this.code = [];
    this.vars.clear();
    this.usesNoise = false;

    // Find Output Node
    const nodes = this.graph._nodes || [];
    const outputNode = nodes.find((n) => n.type === 'shader/output');

    if (!outputNode) {
      return "// No Output Node found. Add a 'Fragment Output' node.";
    }

    const resultVar = this.processInput(outputNode, 0);

    let header = `// Generated by Bevy Shader Graph
#import bevy_pbr::forward_io::VertexOutput
#import bevy_pbr::mesh_view_bindings::globals
`;

    if (this.usesNoise) {
      header += `
fn hash22(p: vec2<f32>) -> vec2<f32> {
    var p3 = fract(vec3<f32>(p.xyx) * vec3<f32>(.1031, .1030, .0973));
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.xx+p3.yz)*p3.zy);
}

fn simplex_noise(p: vec2<f32>) -> f32 {
    let K1 = 0.366025404; // (sqrt(3)-1)/2;
    let K2 = 0.211324865; // (3-sqrt(3))/6;

    let i = floor(p + (p.x + p.y) * K1);
    let a = p - i + (i.x + i.y) * K2;
    let o = select(vec2<f32>(0.0, 1.0), vec2<f32>(1.0, 0.0), a.x > a.y);
    let b = a - o + K2;
    let c = a - 1.0 + 2.0 * K2;

    let h = max(0.5 - vec3<f32>(dot(a,a), dot(b,b), dot(c,c)), vec3<f32>(0.0));

    let n = h*h*h*h * vec3<f32>( dot(a,hash22(i) - 0.5), dot(b,hash22(i + o) - 0.5), dot(c,hash22(i + 1.0) - 0.5));

    return dot(n, vec3<f32>(70.0));
}
`;
    }

    return `${header}
@fragment
fn fragment(in: VertexOutput) -> @location(0) vec4<f32> {
${this.code.join('\n')}
    return ${resultVar};
}`;
  }

  private processInput(node: LGraphNode, slotIndex: number): string {
    if (!node.inputs || !node.inputs[slotIndex]) return this.getDefaultValue(node, slotIndex);

    const linkId = node.inputs[slotIndex].link;
    if (linkId !== null) {
      const link = this.graph.links[linkId];
      if (link) {
        const sourceNode = this.graph.getNodeById(link.origin_id);
        if (sourceNode) {
          return this.processNode(sourceNode, link.origin_slot);
        }
      }
    }

    return this.getInputOrProperty(node, slotIndex);
  }

  private getInputOrProperty(node: LGraphNode, slot: number): string {
    // Check if input has a value directly (from serialization)
    const input = node.inputs[slot];
    // @ts-ignore - litegraph inputs can have values in serialization
    if (input.value !== undefined && input.value !== null) {
      // @ts-ignore
      const v = input.value;
      if (typeof v === 'number') {
        return this.fmt(v);
      }
    }

    // Check widgets_values (common in litegraph for widget-converted inputs)
    if (node.widgets_values && node.widgets_values[slot] !== undefined) {
      const v = node.widgets_values[slot];
      if (typeof v === 'number') {
        return this.fmt(v);
      }
    }

    // Fallback to properties if names match
    const name = input.name.toLowerCase();
    if (node.properties && node.properties[name] !== undefined) {
      const v = node.properties[name];
      if (typeof v === 'number') {
        return this.fmt(v);
      }
    }

    return this.getDefaultValue(node, slot);
  }

  private fmt(n: number) {
    const s = n.toString();
    return s.includes('.') ? s : `${s}.0`;
  }

  private processNode(node: LGraphNode, outputSlot: number): string {
    const key = `${node.id}_${outputSlot}`;
    if (this.vars.has(key)) {
      return this.vars.get(key)!;
    }

    let varName = `v${node.id}_${outputSlot}`;
    let expr = '';

    const fmt = this.fmt;

    switch (node.type) {
      case 'shader/time':
        expr = 'globals.time';
        break;
      case 'shader/uv':
        expr = 'in.uv';
        break;
      case 'shader/color': {
        const c = node.properties.color || [1, 1, 1, 1];
        if (outputSlot === 0)
          expr = `vec4<f32>(${fmt(c[0])}, ${fmt(c[1])}, ${fmt(c[2])}, ${fmt(c[3])})`;
        else if (outputSlot === 1) expr = `vec3<f32>(${fmt(c[0])}, ${fmt(c[1])}, ${fmt(c[2])})`;
        else if (outputSlot === 2) expr = `${fmt(c[3])}`;
        break;
      }
      case 'shader/vector/vec2': {
        const x = this.processInput(node, 0);
        const y = this.processInput(node, 1);
        expr = `vec2<f32>(${x}, ${y})`;
        break;
      }
      case 'shader/vector/vec3': {
        const x = this.processInput(node, 0);
        const y = this.processInput(node, 1);
        const z = this.processInput(node, 2);
        expr = `vec3<f32>(${x}, ${y}, ${z})`;
        break;
      }
      case 'shader/vector/vec4': {
        const x = this.processInput(node, 0);
        const y = this.processInput(node, 1);
        const z = this.processInput(node, 2);
        const w = this.processInput(node, 3);
        expr = `vec4<f32>(${x}, ${y}, ${z}, ${w})`;
        break;
      }
      case 'shader/vector/combine_vec3_float': {
        const rgb = this.processInput(node, 0);
        const a = this.processInput(node, 1);
        expr = `vec4<f32>(${rgb}, ${a})`;
        break;
      }
      case 'shader/noise/simplex': {
        this.usesNoise = true;
        const uv = this.processInput(node, 0);
        const scale = this.processInput(node, 1);
        expr = `simplex_noise(${uv} * ${scale})`;
        break;
      }
      case 'shader/math/length': {
        const i = this.processInput(node, 0);
        expr = `length(${i})`;
        break;
      }
      case 'shader/math/distance': {
        const a = this.processInput(node, 0);
        const b = this.processInput(node, 1);
        expr = `distance(${a}, ${b})`;
        break;
      }
      case 'shader/math/sin': {
        const input = this.processInput(node, 0);
        expr = `sin(${input})`;
        break;
      }
      case 'shader/math/float_add': {
        const a = this.processInput(node, 0);
        const b = this.processInput(node, 1);
        expr = `(${a} + ${b})`;
        break;
      }
      case 'shader/math/float_sub': {
        const a = this.processInput(node, 0);
        const b = this.processInput(node, 1);
        expr = `(${a} - ${b})`;
        break;
      }
      case 'shader/math/float_mul': {
        const a = this.processInput(node, 0);
        const b = this.processInput(node, 1);
        expr = `(${a} * ${b})`;
        break;
      }
      case 'shader/math/float_div': {
        const a = this.processInput(node, 0);
        const b = this.processInput(node, 1);
        expr = `(${a} / ${b})`;
        break;
      }
      case 'shader/math/add': {
        const a = this.processInput(node, 0);
        const b = this.processInput(node, 1);
        expr = `(${a} + ${b})`;
        break;
      }
      case 'shader/math/sub': {
        const a = this.processInput(node, 0);
        const b = this.processInput(node, 1);
        expr = `(${a} - ${b})`;
        break;
      }
      case 'shader/math/mul': {
        const a = this.processInput(node, 0);
        const b = this.processInput(node, 1);
        expr = `(${a} * ${b})`;
        break;
      }
      case 'shader/math/div': {
        const a = this.processInput(node, 0);
        const b = this.processInput(node, 1);
        expr = `(${a} / ${b})`;
        break;
      }
      case 'shader/math/mix': {
        const a = this.processInput(node, 0);
        const b = this.processInput(node, 1);
        const t = this.processInput(node, 2);
        expr = `mix(${a}, ${b}, ${t})`;
        break;
      }
      case 'shader/math/step': {
        const e = this.processInput(node, 0);
        const i = this.processInput(node, 1);
        expr = `step(${e}, ${i})`;
        break;
      }
      case 'shader/math/smoothstep': {
        const e1 = this.processInput(node, 0);
        const e2 = this.processInput(node, 1);
        const i = this.processInput(node, 2);
        expr = `smoothstep(${e1}, ${e2}, ${i})`;
        break;
      }
      case 'shader/math/fract': {
        const i = this.processInput(node, 0);
        expr = `fract(${i})`;
        break;
      }
      case 'shader/math/oneminus': {
        const i = this.processInput(node, 0);
        expr = `(1.0 - ${i})`;
        break;
      }
      default:
        expr = 'vec4<f32>(1.0, 0.0, 1.0, 1.0)';
        this.code.push(`    // Unknown node type: ${node.type}`);
    }

    this.code.push(`    let ${varName} = ${expr};`);
    this.vars.set(key, varName);
    return varName;
  }

  private getDefaultValue(node: LGraphNode, slot: number): string {
    const type = node.inputs && node.inputs[slot] ? node.inputs[slot].type : 'float';
    if (type === 'float') return '0.0';
    if (type === 'vec2') return 'vec2<f32>(0.0)';
    if (type === 'vec3') return 'vec3<f32>(0.0)';
    return 'vec4<f32>(0.0, 0.0, 0.0, 1.0)';
  }
}
